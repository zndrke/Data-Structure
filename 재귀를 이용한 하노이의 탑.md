재귀를 이용한 하노이의 탑



3개의 기둥 A,B,C를 가지고 n개의 원반을 옮기는 방법

조건은 다음과 같다

- 원반을 기둥 A에서 기둥 C로 옮긴다. 
- 작은 원반 위에 큰 원반을 올릴 수 없다.

![하노이탑](C:\Users\창용\Desktop\타이포라\하노이탑.PNG)

하노이의 탑은 대표적인 재귀 알고리즘을 통해 해결하는 문제.



재귀가 성립하는 이유는 디스크가 3개일 때와 4개일 때를 보면 이해하기 쉽다.



- 디스크 3개 (2^3-1=7번)

  ![하노이 3개](C:\Users\창용\Desktop\타이포라\하노이 3개.PNG)

- 디스크 4개(2^4-1=15번)

![하노이 4개 설명](C:\Users\창용\Desktop\타이포라\하노이 4개 설명.PNG)

디스크 3개일 때의 과정(8번)이 디스크 4개일 때의 과정 안에(파란색 부분) 포함되어 있다.

기둥의 위치를 고려하여 A와 B를 바꿔 생각하면 편하다.

**즉, A에 있는 n개의 디스크를 옮기는 것은**  

**A에서 B로 n-1개의 디스크를 옮기고,**

**n번째 디스크를 C로 옮기고,**

**B에 있는 n-1개의 디스크를 C로 옮기는 것이다.**



n개의 디스크를 옮기는 횟수는 

n-1개의 디스크를 A에서 B로 옮기는 횟수 => 2^n-1

n번째 디스크를 A에서 C로 옮기는 횟수 => 1

n-1번째 디스크를 B에서 C로 옮기는 횟수 => 2^n-1

=> (2^n-1)+(2^n-1)+1= 2^n-1

즉, 2^n-1



코드는 다음과 같다.

```c
#include <stdio.h>
 
 int hanoi(int n, char from,char tmp, char to){
 	if (n==1)                                            //재귀의 종료조건
 		printf("원판 1을 %c에서 %c으로 옮긴다.\n",from,to); //마지막 디스크를 옮김
 		
else{
	hanoi(n-1,from,to,tmp);       // 1번 ~ n-1번째까지 디스크를 from에서 tmp로 
	printf("원판 %d를 %c에서 %c로 옮긴다.\n",n,from,to); //n번째 디스크를 from에서 to로
	hanoi(n-1,tmp,from,to);       //tmp에 있던 1번~n-1번째까지 디스크를 to로 옮김 
} 
	
 }
 
 int main(){
 	hanoi(3,'a','b','c');
 	return 0;
 }
```



